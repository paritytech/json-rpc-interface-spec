<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="why-json-rpc.html"><strong aria-hidden="true">1.1.</strong> Why JSON-RPC?</a></li></ol></li><li class="chapter-item expanded "><a href="api/introduction.html"><strong aria-hidden="true">2.</strong> API specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/archive.html"><strong aria-hidden="true">2.1.</strong> archive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/archive_unstable_body.html"><strong aria-hidden="true">2.1.1.</strong> archive_unstable_body</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_genesisHash.html"><strong aria-hidden="true">2.1.2.</strong> archive_unstable_genesisHash</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_hashByHeight.html"><strong aria-hidden="true">2.1.3.</strong> archive_unstable_hashByHeight</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_header.html"><strong aria-hidden="true">2.1.4.</strong> archive_unstable_header</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_stopBody.html"><strong aria-hidden="true">2.1.5.</strong> archive_unstable_stopBody</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_stopHashByHeight.html"><strong aria-hidden="true">2.1.6.</strong> archive_unstable_stopHashByHeight</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_stopHeader.html"><strong aria-hidden="true">2.1.7.</strong> archive_unstable_stopHeader</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_stopStorage.html"><strong aria-hidden="true">2.1.8.</strong> archive_unstable_stopStorage</a></li><li class="chapter-item expanded "><a href="api/archive_unstable_storage.html"><strong aria-hidden="true">2.1.9.</strong> archive_unstable_storage</a></li></ol></li><li class="chapter-item expanded "><a href="api/chainHead.html"><strong aria-hidden="true">2.2.</strong> chainHead</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/chainHead_unstable_body.html"><strong aria-hidden="true">2.2.1.</strong> chainHead_unstable_body</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_call.html"><strong aria-hidden="true">2.2.2.</strong> chainHead_unstable_call</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_follow.html"><strong aria-hidden="true">2.2.3.</strong> chainHead_unstable_follow</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_genesisHash.html"><strong aria-hidden="true">2.2.4.</strong> chainHead_unstable_genesisHash</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_header.html"><strong aria-hidden="true">2.2.5.</strong> chainHead_unstable_header</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_stopBody.html"><strong aria-hidden="true">2.2.6.</strong> chainHead_unstable_stopBody</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_stopCall.html"><strong aria-hidden="true">2.2.7.</strong> chainHead_unstable_stopCall</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_stopStorage.html"><strong aria-hidden="true">2.2.8.</strong> chainHead_unstable_stopStorage</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_storage.html"><strong aria-hidden="true">2.2.9.</strong> chainHead_unstable_storage</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_unfollow.html"><strong aria-hidden="true">2.2.10.</strong> chainHead_unstable_unfollow</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_unpin.html"><strong aria-hidden="true">2.2.11.</strong> chainHead_unstable_unpin</a></li><li class="chapter-item expanded "><a href="api/chainHead_unstable_wasmQuery.html"><strong aria-hidden="true">2.2.12.</strong> chainHead_unstable_wasmQuery</a></li></ol></li><li class="chapter-item expanded "><a href="api/chainSpec.html"><strong aria-hidden="true">2.3.</strong> chainSpec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/chainSpec_unstable_chainName.html"><strong aria-hidden="true">2.3.1.</strong> chainSpec_unstable_chainName</a></li><li class="chapter-item expanded "><a href="api/chainSpec_unstable_genesisHash.html"><strong aria-hidden="true">2.3.2.</strong> chainSpec_unstable_genesisHash</a></li><li class="chapter-item expanded "><a href="api/chainSpec_unstable_properties.html"><strong aria-hidden="true">2.3.3.</strong> chainSpec_unstable_properties</a></li></ol></li><li class="chapter-item expanded "><a href="api/extrinsic.html"><strong aria-hidden="true">2.4.</strong> extrinsic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/extrinsic_unstable_submitAndWatch.html"><strong aria-hidden="true">2.4.1.</strong> extrinsic_unstable_submitAndWatch</a></li><li class="chapter-item expanded "><a href="api/extrinsic_unstable_unwatch.html"><strong aria-hidden="true">2.4.2.</strong> extrinsic_unstable_unwatch</a></li></ol></li><li class="chapter-item expanded "><a href="api/rpc.html"><strong aria-hidden="true">2.5.</strong> rpc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/rpc_methods.html"><strong aria-hidden="true">2.5.1.</strong> rpc_methods</a></li></ol></li><li class="chapter-item expanded "><a href="api/sudo.html"><strong aria-hidden="true">2.6.</strong> sudo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/sudo_unstable_addReservedPeer.html"><strong aria-hidden="true">2.6.1.</strong> sudo_unstable_addReservedPeer</a></li><li class="chapter-item expanded "><a href="api/sudo_unstable_pendingExtrinsics.html"><strong aria-hidden="true">2.6.2.</strong> sudo_unstable_pendingExtrinsics</a></li><li class="chapter-item expanded "><a href="api/sudo_unstable_removeReservedPeer.html"><strong aria-hidden="true">2.6.3.</strong> sudo_unstable_removeReservedPeer</a></li><li class="chapter-item expanded "><a href="api/sudo_unstable_rotateKeys.html"><strong aria-hidden="true">2.6.4.</strong> sudo_unstable_rotateKeys</a></li><li class="chapter-item expanded "><a href="api/sudo_unstable_version.html"><strong aria-hidden="true">2.6.5.</strong> sudo_unstable_version</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="grouping-functions-and-node-capabilities"><a class="header" href="#grouping-functions-and-node-capabilities">Grouping functions and node capabilities</a></h2>
<p>Before going further, let's examine <em>why</em> we're building a JSON-RPC interface at all:</p>
<ul>
<li>For end-user-facing applications to be able to read and interact with a blockchain.</li>
<li>For node operators to make sure that their node is operating correctly, and perform some operations such as rotating keys.</li>
<li>For core/parachain developers to manually look at the state of the blockchain and figure out what is on the chain.</li>
</ul>
<p>These three audiences have different needs, and it doesn't make sense for example for a light client to support a function that rotates keys.</p>
<p>It is already the case today that light clients only support a subset of all JSON-RPC functions, and publicly-accessible JSON-RPC full nodes also only support a subset of all JSON-RPC functions.</p>
<p>In order to do this properly, we suggest to distribute all JSON-RPC functions between groups, and nodes are allowed to support only a certain subset of groups. However, each group, if it is supported, must be supported entirely. The group a JSON-RPC function belongs to is indicated by a <code>prefix_</code> in its name.</p>
<p>The groups must also include a version number. For example, each function prefixed with <code>foo_v1_</code> belong to version 1 of the group <code>foo</code>. Multiple versions of the same group name might co-exist in the future. Remember that some servers might support <code>foo_v2_</code> and not <code>foo_v1_</code>, or vice versa. As such, each group+version must be &quot;self-contained&quot;.
Functions from multiple different group+version should never be mixed. For example, <code>foo_v1_start</code> can only be stopped with <code>foo_v1_stop</code> and <code>foo_v2_start</code> can only be stopped with <code>foo_v2_stop</code>. <code>foo_v1_stop</code> must not be able to stop <code>foo_v2_start</code> and vice versa.
Functions that are unstable should always use version <code>unstable</code> of a group. For instance, <code>foo_unstable_</code>. Functions must be stable only if we are forever ready to commit to their stability. Unstable functions can break at any time, and thus more freedom is given to them.
We understand that developers want to be able to add RPC functions for various reasons, such as debugging. When doing so, they are strongly encouraged to assign functions to a group with the <code>_unstable</code> prefix.
It is completely fine to leave functions as unstable forever and never try to stabilize them. In particular, there is no drawback in leaving as unstable functions that aren't meant to be called programmatically.</p>
<p>JSON-RPC server should always support the <code>rpc_methods</code> function, and clients should use this function to determine which other functions are supported.</p>
<p><strong>Note</strong>: Protocol specification formats such as https://open-rpc.org/ have been considered, but are unfortunately lacking the capabilities to describe subscriptions, and their interest is therefore limited.</p>
<h2 id="guiding-principles-for-new-functions"><a class="header" href="#guiding-principles-for-new-functions">Guiding principles for new functions</a></h2>
<p>All the functions in the new API should conform to the following:</p>
<ul>
<li>camelCase and not snake_case, as this is the norm in JavaScript.</li>
<li>Function names must start with a prefix indicating the category the function belongs to.</li>
<li>Functions should keep in mind the fact that they might be called on a load balancer, and that requests could be distributed between multiple nodes. For example, after submitting a transaction, retrieving the list of pending transactions might return an empty list, because the submission was sent to a different node than the one the list was retrieved from.</li>
<li>Functions should only generate errors in case of a communication issue between the client and server (e.g. missing parameter, unknown function), or in case of a problem with the node (e.g. processing the request triggers a panic, or the node detected that it wasn't compatible with the chain it is supposed to connect to). Functions shouldn't generate JSON-RPC errors in circumstances that can happen normally, for example the impossibility to access a storage item due to lack of connectivity. This lets a JSON-RPC client implementation treat all JSON-RPC errors as critical problems, rather than having to interpret these errors.</li>
<li>Functions that produce notifications should keep in mind that it must be possible for a JSON-RPC server to drop notifications in case the client isn't processing them quickly enough. Example: let's take the <code>chain_subscribeNewHeads</code> function that reports updates about the new best block. A server can implement this by detecting when a new best block happens then trying to send a notification. After the notification has been sent, the server then checks whether the best block is still the same as the one that was notified, and if not sends a notification again. This implementation uses a fixed amount of memory, which is a good thing, but might lead to some best block updates being missed (e.g. if the best block changes multiple times while trying to send the notification). If it was mandatory for the server to report every single best block update, it would have no choice but to buffer all the updates that happen while sending a notification, which could lead to an infinite amount of memory being used. For this reason, it must not be mandatory to report every single best block update.</li>
<li>No JSON-RPC function should use up a disproportionate amount of CPU power in order to be answered compared to the other functions, in order to avoid a situation where a few expensive calls in front of the queue are blocking cheap callers behind them.</li>
<li>Implementations of this API should enforce a limit to the number of simultaneous subscriptions, meaning that all active subscriptions should have roughly the same CPU/memory cost for the implementation.</li>
<li>It is <strong>not</strong> an objective to optimize the bandwidth usage of JSON-RPC client &lt;-&gt; server communication, as all the idiomatic usages of this API involve communicating through <code>localhost</code>. However it should still be realistic to use TCP/IP as a quick solution. Similarly, it is not an objective to minimize the number of round-trips necessary between the JSON-RPC client and server.</li>
<li>The objective of this interface is to give clear, explicit, and direct access to a node's internal state, and <strong>not</strong> to be convenient to use. Functions that require, for example, some post-processing on the data should be avoided, and caches should preferably be found on the client side rather than the server side. High-level developers are not expected to directly use the client side of this interface, but instead to use an intermediary layer on top of this client side.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-json-rpc"><a class="header" href="#why-json-rpc">Why JSON-RPC?</a></h1>
<p>The JSON-RPC protocol has been chosen over other protocols such as gRPC due to its simplicity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-specification"><a class="header" href="#api-specification">API specification</a></h1>
<p>Note that all parameters are mandatory unless specified otherwise. All functions support two ways of calling them: either by passing an array with an ordered list of parameters, or by passing an object where parameters are named.</p>
<p>Any missing parameter, or parameter with an invalid format, should result in a JSON-RPC error being returned, as described in the JSON-RPC specification.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li>&quot;hexadecimal-encoded&quot; designates a binary value encoded as hexadecimal. The value must either be empty, or start with <code>&quot;0x&quot;</code> and contain an even number of characters.</li>
<li>&quot;SCALE-encoded&quot; designates a value encoded using <a href="https://docs.substrate.io/v3/advanced/scale-codec/">the SCALE codec</a>.</li>
</ul>
<h2 id="the-networkconfig-parameter"><a class="header" href="#the-networkconfig-parameter">The <code>networkConfig</code> parameter</a></h2>
<p>Many functions in the API have an optional parameter named <code>networkConfig</code>. This parameter is used when a function needs to request an information from its peers.</p>
<p>Requesting an information from a peer involves sending a request to this peer. This request can fail for various reasons: the peer is non responsive, the peer is overwhelmed, the peer is malicious, the peer has a bug in its implementation, etc. Because the request can fail, multiple requests should be attempted towards different peers before the information retrieval fails altogether.</p>
<p>The passed passed for the <code>networkConfig</code> parameter is a struct defined as:</p>
<pre><code class="language-json">{
    &quot;totalAttempts&quot;: ...,
    &quot;maxParallel&quot;: ...,
    &quot;timeoutMs&quot;: ...
}
</code></pre>
<ul>
<li><code>totalAttempts</code> is an integer indicating the total number of peers to request for the information.</li>
<li><code>maxParallel</code> is an integer indicating the maximum number of requests to perform in parallel. A value of 0 is illegal.</li>
<li><code>timeoutMs</code> is an integer indicating the time, in milliseconds, after which a single request (towards one peer) is considered unsuccessful.</li>
</ul>
<p>These values can be tweaked depending on the urgency of the JSON-RPC function call. An important information should be queried with a low timeout and high number of <code>maxParallel</code>, while a low priority information should be queried with <code>maxParallel</code> equal to 1.
A JSON-RPC function call that is passed a <code>networkConfig</code> can take, in the worst case scenario, a bit more than <code>timeoutMs * totalAttempts / maxParallel</code> milliseconds.</p>
<p>The JSON-RPC server implementation is allowed and strongly encouraged to put hard a limit on the values in the <code>networkConfig</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Functions with the <code>archive</code> prefix allow obtaining the state of the chain at any point in the present or in the past.</p>
<p>These functions are meant to be used to inspect the history of a chain. They can be used to access recent information as well, but JSON-RPC clients should keep in mind that the <code>chainHead</code> functions could be more appropriate.</p>
<p>These functions are typically expensive for a JSON-RPC server, because they likely have to perform either disk accesses or network requests. Consequently, JSON-RPC servers are encouraged to put a global limit on the number of concurrent calls to <code>archive</code>-prefixed functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_body"><a class="header" href="#archive_unstable_body">archive_unstable_body</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_genesishash"><a class="header" href="#archive_unstable_genesishash">archive_unstable_genesisHash</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: String containing the hexadecimal-encoded hash of the genesis block of the chain.</p>
<p>This function is a simple getter. The JSON-RPC server is expected to keep in its memory the hash of the genesis block.</p>
<p>The value returned by this function must never change for the lifetime of the connection between the JSON-RPC client and server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_hashbyheight"><a class="header" href="#archive_unstable_hashbyheight">archive_unstable_hashByHeight</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>height</code>: String containing an hexadecimal-encoded integer.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the query in progress.</p>
<p>The JSON-RPC client must find the blocks (zero, one, or more) whose height is the one passed as parameter. If the <code>height</code> is inferior or equal to the finalized block height, then only finalized blocks must be fetched and returned.</p>
<p>This function will later generate a notification in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;archive_unstable_hashByHeightEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>result</code> can be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;done&quot;,
    &quot;output&quot;: [...]
}
</code></pre>
<p>Where <code>output</code> is an array of hexadecimal-encoded hashes corresponding to the blocks of this height that are known to the node. If the <code>height</code> is inferior or equal to the finalized block height, the array must contain either zero or one entry.</p>
<p>Only one notification will ever be generated.</p>
<p><strong>Note</strong>: Other events might be added in the future, such as reports on the progress of the query.</p>
<p><strong>Important implementation note</strong>: While it is possible for a light client to ask its peers which block hash corresponds to a certain height, it is at the moment impossible to obtain a proof of this. If a light client implements this JSON-RPC function, it must only look in its internal memory and <strong>not</strong> ask the network. Consequently, calling this function with a height more than a few blocks away from the finalized block height will always return zero blocks. Despite being currently useless, the <code>networkConfig</code> parameter is kept for the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_header"><a class="header" href="#archive_unstable_header">archive_unstable_header</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>hash</code>: String containing the hexadecimal-encoded hash of the header to retreive.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the query in progress.</p>
<p>This function will later generate a notification in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;archive_unstable_headerEvent&quot;,
    &quot;params&quot;:{
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>result</code> can be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;done&quot;,
    &quot;output&quot;: ...
}
</code></pre>
<p>Where <code>output</code> is a string containing the hexadecimal-encoded SCALE-codec encoding of the header of the block.</p>
<p>Alternatively, <code>result</code> can also be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;failed&quot;
}
</code></pre>
<p>Only one notification will ever be generated.</p>
<p><strong>Note</strong>: Other events might be added in the future, such as reports on the progress of the call.</p>
<h2 id="possible-errors"><a class="header" href="#possible-errors">Possible errors</a></h2>
<p>If the block hash passed as parameter doesn't correspond to any known block, then a <code>{&quot;event&quot;: &quot;failed&quot;}</code> notification is generated (as explained above).</p>
<p>If the networking part of the behaviour fails, then a <code>{&quot;event&quot;: &quot;failed&quot;}</code> notification is generated (as explained above).</p>
<p>Due to the way blockchains work, it is never possible to be certain that a block doesn't exist. For this reason, networking-related errors and unknown block errors are reported in the same way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_stopbody"><a class="header" href="#archive_unstable_stopbody">archive_unstable_stopBody</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_stophashbyheight"><a class="header" href="#archive_unstable_stophashbyheight">archive_unstable_stopHashByHeight</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>archive_unstable_hashByHeight</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a query started with <code>archive_unstable_hashByHeight</code>. If the query was still in progress, this interrupts it. If the query was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this call, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-1"><a class="header" href="#possible-errors-1">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_stopheader"><a class="header" href="#archive_unstable_stopheader">archive_unstable_stopHeader</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>archive_unstable_header</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a query started with <code>archive_unstable_header</code>. If the query was still in progress, this interrupts it. If the query was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this call, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-2"><a class="header" href="#possible-errors-2">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_stopstorage"><a class="header" href="#archive_unstable_stopstorage">archive_unstable_stopStorage</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>archive_unstable_storage</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a storage fetch started with <code>archive_unstable_storage</code>. If the storage fetch was still in progress, this interrupts it. If the storage fetch was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this storage fetch, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-3"><a class="header" href="#possible-errors-3">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive_unstable_storage"><a class="header" href="#archive_unstable_storage">archive_unstable_storage</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>hash</code>: String containing an hexadecimal-encoded hash of the header of the block whose storage to fetch.</li>
<li><code>key</code>: String containing the hexadecimal-encoded key to fetch in the storage.</li>
<li><code>childKey</code>: <code>null</code> for main storage look-ups, or a string containing the hexadecimal-encoded key of the trie key of the trie that <code>key</code> refers to. <strong>TODO</strong>: I don't know enough about child tries to design this properly</li>
<li><code>type</code>: String that must be equal to one of: <code>value</code>, <code>hash</code>, or <code>size</code>.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the storage fetch in progress.</p>
<p>This function works the same way as <code>chainHead_unstable_storage</code>, except that it is not connected to a chain head follow, and no <code>disjoint</code> event can be generated.</p>
<p>Note that <code>chainHead_unstable_storage</code> and <code>archive_unstable_storage</code> should be treated as two completely separate functions. It is forbidden to call <code>archive_unstable_stopStorage</code> with a storage fetch started with <code>chainHead_unstable_storage</code>, and vice versa. Some JSON-RPC servers might support only one of these functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<p>Functions with the <code>chainHead</code> prefix allow tracking the head of the chain (in other words, the latest new and finalized blocks) and their storage.</p>
<p>The most important function in this category is <code>chainHead_unstable_follow</code>. It is the first function that is the user is expected to call, before (almost) any other. <code>chainHead_unstable_follow</code> returns the current list of blocks that are near the head of the chain, and generates notifications about new blocks. The <code>chainHead_unstable_body</code>, <code>chainHead_unstable_call</code>, <code>chainHead_unstable_header</code> and <code>chainHead_unstable_storage</code> functions can be used to obtain more details about the blocks that have been reported by <code>chainHead_unstable_follow</code>.</p>
<p>These functions are the functions most of the JSON-RPC clients will most commonly use. A JSON-RPC server implementation is encouraged to prioritize serving these functions over other functions, and to put pinned blocks in a quickly-accessible cache.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_body"><a class="header" href="#chainhead_unstable_body">chainHead_unstable_body</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
<li><code>hash</code>: String containing an hexadecimal-encoded hash of the header of the block whose body to fetch.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the body fetch in progress.</p>
<p>The JSON-RPC server must start obtaining the body (in other words the list of transactions) of the given block.</p>
<p>This function will later generate notifications in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;chainHead_unstable_bodyEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>If everything is successful, <code>result</code> will be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;done&quot;,
    &quot;value&quot;: [...]
}
</code></pre>
<p>Where <code>value</code> is an array of strings containing the hexadecimal-encoded SCALE-encoded extrinsics found in this block.</p>
<p>Alternatively, <code>result</code> can also be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;failed&quot;
}
</code></pre>
<p>Which indicates that the body has failed to be retrieved from the network.</p>
<p>Alternatively, if the <code>followSubscriptionId</code> is dead, then <code>result</code> can also be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;disjoint&quot;
}
</code></pre>
<p>After an <code>&quot;event&quot;: &quot;done&quot;</code>, <code>&quot;event&quot;: &quot;failed&quot;</code>, or <code>&quot;event&quot;: &quot;disjoint&quot;</code> is received, no more notification will be generated.</p>
<p><strong>Note</strong>: Other events might be added in the future, such as reports on the progress of the fetch.</p>
<h2 id="possible-errors-4"><a class="header" href="#possible-errors-4">Possible errors</a></h2>
<ul>
<li>If the networking part of the behaviour fails, then a <code>{&quot;event&quot;: &quot;failed&quot;}</code> notification is generated (as explained above).</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is invalid.</li>
<li>If the <code>followSubscriptionId</code> is dead, then a <code>{&quot;event&quot;: &quot;disjoint&quot;}</code> notification is generated (as explained above).</li>
<li>A JSON-RPC error is generated if the block hash passed as parameter doesn't correspond to any block that has been reported by <code>chainHead_unstable_follow</code>.</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is valid but the block hash passed as parameter has already been unpinned.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_call"><a class="header" href="#chainhead_unstable_call">chainHead_unstable_call</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
<li><code>hash</code>: String containing the hexadecimal-encoded hash of the header of the block to make the call against.</li>
<li><code>function</code>: Name of the runtime entry point to call as a string.</li>
<li><code>callParameters</code>: Array containing a list of hexadecimal-encoded SCALE-encoded parameters to pass to the runtime function.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the call in progress.</p>
<p><strong>TODO</strong>: in order to perform the runtime call, the implementation of this function will simply concatenate all the parameters (without any separator), so does it make sense for the JSON-RPC function to require to split them into an array?</p>
<p>This function will later generate a notification in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;chainHead_unstable_callEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>result</code> can be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;done&quot;,
    &quot;output&quot;: &quot;0x0000000...&quot;
}
</code></pre>
<p>Where <code>output</code> is the hexadecimal-encoded output of the runtime function call.</p>
<p>Alternatively, <code>result</code> can also be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;failed&quot;,
    &quot;error&quot;: &quot;...&quot;
}
</code></pre>
<p>Where <code>error</code> is a human-readable error message indicating why the call has failed. This string isn't meant to be shown to end users, but is for developers to understand the problem.</p>
<p>Alternatively, if the <code>followSubscriptionId</code> is dead, then <code>result</code> can also be:</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;disjoint&quot;
}
</code></pre>
<p>Only one notification will ever be generated.</p>
<p><strong>Note</strong>: Other events might be added in the future, such as reports on the progress of the call.</p>
<p><strong>Note</strong>: This can be used as a replacement for <code>state_getMetadata</code>, <code>system_accountNextIndex</code>, and <code>payment_queryInfo</code>.</p>
<h2 id="possible-errors-5"><a class="header" href="#possible-errors-5">Possible errors</a></h2>
<p><strong>TODO</strong>: more precise</p>
<ul>
<li>If the block hash passed as parameter doesn't correspond to any known block, then a <code>{&quot;event&quot;:&quot;failed&quot;,&quot;error&quot;:&quot;...&quot;}</code> notification is generated (as explained above).</li>
<li>If the JSON-RPC server is incapable of executing the Wasm runtime of the given block, a JSON-RPC error should be returned.</li>
<li>If the method to call doesn't exist in the Wasm runtime of the chain, <strong>TODO</strong>.</li>
<li>If the runtime call fails (e.g. because it triggers a panic in the runtime, running out of memory, etc., or if the runtime call takes too much time), then <strong>TODO</strong>.</li>
<li>If the networking part of the behaviour fails, then a <code>{&quot;event&quot;:&quot;failed&quot;,&quot;error&quot;:&quot;...&quot;}</code> notification is generated (as explained above).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_follow"><a class="header" href="#chainhead_unstable_follow">chainHead_unstable_follow</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>runtimeUpdates</code>: A boolean indicating whether the events should report changes to the runtime.</li>
</ul>
<p><strong>Return value</strong>: String containing an opaque value representing the subscription.</p>
<p>This functions lets the JSON-RPC client track the state of the head of the chain: the finalized, non-finalized, and best blocks.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>This function works as follows:</p>
<ul>
<li>
<p>When called, returns an opaque <code>followSubscriptionId</code> that can used to match events and in various other <code>chainHead</code>-prefixed functions.</p>
</li>
<li>
<p>Later, generates an <code>initialized</code> notification (see below) containing the hash of the current finalized block, and, if <code>runtimeUpdates</code> is <code>true</code>, the runtime specification of the runtime of the current finalized block.</p>
</li>
<li>
<p>Afterwards, generates one <code>newBlock</code> notification (see below) for each non-finalized block currently in the node's memory (including all forks), then a <code>bestBlockChanged</code> notification. The notifications must be sent in an ordered way such that the parent of each block either can be found in an earlier notification or is the current finalized block.</p>
</li>
<li>
<p>When a new block arrives, generates a <code>newBlock</code> notification. If the new block is also the new best block of the node, also generates a <code>bestBlockChanged</code> notification.</p>
</li>
<li>
<p>When the node finalizes a block, generates a <code>finalized</code> notification indicating which blocks have been finalized and which blocks have been pruned.</p>
</li>
<li>
<p>If the node is overloaded and cannot avoid a gap in the notifications, or in case of a warp syncing, or if the maximum number of pinned blocks is reached (see below), generates a <code>stop</code> notification indicating that the subscription is now dead and must be re-created. No more notifications will be sent out on this subscription.</p>
</li>
</ul>
<p><strong>Note</strong>: This list of notifications makes it very easy for a JSON-RPC client to follow just the best block updates (listening to just <code>bestBlockChanged</code> events) or follow just the finalized block updates (listening to just <code>initialized</code> and <code>finalized</code> events). It is however not possible to easily figure out whether the runtime has been modified when these updates happen. This is not problematic, as anyone using the JSON-RPC interface naively propably doesn't need to account for runtime changes anyway.</p>
<h2 id="the-runtimeupdates-parameter"><a class="header" href="#the-runtimeupdates-parameter">The <code>runtimeUpdates</code> parameter</a></h2>
<p>If the <code>runtimeUpdates</code> parameter is <code>true</code>, then blocks shouldn't (and can't) be reported to JSON-RPC clients before the JSON-RPC server has finished obtaining the runtime specification of the blocks that it reports. This includes the finalized block reported in the <code>initialized</code> event.</p>
<p>If <code>runtimeUpdates</code> is <code>false</code>, then the <code>initialized</code> event must be sent back quickly after the function returns. If <code>runtimeUpdates</code> is <code>true</code>, then the JSON-RPC server can take as much time as it wants to send back the <code>initialized</code> event.</p>
<p>For this reason, blocks might be reported more quickly when <code>runtimeUpdates</code> is <code>false</code>.</p>
<p><strong>Note</strong>: It is unlikely that high-level UIs built on top of a JSON-RPC client can do anything before the JSON-RPC server has access to the runtime. Consequently, they should consider the time before the <code>initialized</code> event is generated as a loading time. During this loading time, the JSON-RPC server might be performing downloads and CPU-intensive operations.</p>
<p>If a JSON-RPC client wants to be sure to receive an <code>initialized</code> event quickly but is also interested in the runtime, it is encouraged to create two subscriptions: one with <code>runtimeUpdates: true</code> and one with <code>runtimeUpdates: false</code>.</p>
<h2 id="notifications-format"><a class="header" href="#notifications-format">Notifications format</a></h2>
<p>This function will later generate one or more notifications in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;chainHead_unstable_followEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>subscriptionId</code> is the value returned by this function, and <code>result</code> can be one of:</p>
<h3 id="initialized"><a class="header" href="#initialized">initialized</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;initialized&quot;,
    &quot;finalizedBlockHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;finalizedBlockRuntime&quot;: ...
}
</code></pre>
<p>The <code>initialized</code> event is always the first event to be sent back, and is only ever sent back once per subscription.</p>
<p><code>finalizedBlockRuntime</code> is present if and only if <code>runtimeUpdates</code>, the parameter to this function, is <code>true</code>.</p>
<p>The format of <code>finalizedBlockRuntime</code> is described later down this page.</p>
<h3 id="newblock"><a class="header" href="#newblock">newBlock</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;newBlock&quot;,
    &quot;blockHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;parentBlockHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;newRuntime&quot;: ...
}
</code></pre>
<p>The <code>newBlock</code> indicates a new non-finalized block.</p>
<p><code>parentBlockHash</code> is guaranteed to be equal either to the current finalized block hash, or to a block reported in an earlier <code>newBlock</code> event.</p>
<p><code>newRuntime</code> must not be present if <code>runtimeUpdates</code>, the parameter to this function, is <code>false</code>. <code>newRuntime</code> must be <code>null</code> if the runtime hasn't changed compared to its parent.</p>
<p>If present and non-null, the format of <code>newRuntime</code> is the same as the <code>finalizedBlockRuntime</code> field in the <code>initialized</code> event and is explained later down this page.</p>
<h3 id="bestblockchanged"><a class="header" href="#bestblockchanged">bestBlockChanged</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;bestBlockChanged&quot;,
    &quot;bestBlockHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;
}
</code></pre>
<p>The <code>bestBlockChanged</code> event indicates that the given block is now considered to be the best block.</p>
<p><code>bestBlockHash</code> is guaranteed to be equal either to the current finalized block hash, or to a block reported in an earlier <code>newBlock</code> event.</p>
<h3 id="finalized"><a class="header" href="#finalized">finalized</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;finalized&quot;,
    &quot;finalizedBlocksHashes&quot;: [
        &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
        &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;
    ],
    &quot;prunedBlocksHashes&quot;: [
        &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
        &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;
    ]
}
</code></pre>
<p>The <code>finalized</code> event indicates that some of the blocks that have earlier been reported with <code>newBlock</code> events are now either finalized or no longer relevant.</p>
<p><code>finalizedBlocksHashes</code> contains a list of blocks that are now part of the finalized block, ordered by increasing block number. The last element in this list is the current finalized block.</p>
<p><code>prunedBlocksHashes</code> contains, in no particular order, a list of blocks that are not descendants of the latest finalized block. These blocks will never be finalized and can be discarded.</p>
<p>All items in <code>finalizedBlocksHashes</code> and <code>prunedBlocksHashes</code> are guaranteed to have been reported through earlier <code>newBlock</code> events.</p>
<p>The current best block, in other words the last block reported through a <code>bestBlockChanged</code> event, is guaranteed to either be the last item in <code>finalizedBlocksHashes</code>, or to not be present in either <code>finalizedBlocksHashes</code> or <code>prunedBlocksHashes</code>.</p>
<h3 id="stop"><a class="header" href="#stop">stop</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;stop&quot;
}
</code></pre>
<p>The <code>stop</code> event indicates that the JSON-RPC server was unable to provide a consistent list of the blocks at the head of the chain. This can happen because too many blocks have been pinned, because doing so would use an unreasonable amount of memory, or because a consensus mechanism creates a gap in the chain.</p>
<p><strong>Note</strong>: In particular, warp syncing algorithms create a &quot;jump&quot; in the chain from a block to a much later block. Any subscription that is active when the warp syncing happens will receive a <code>stop</code> event.</p>
<h2 id="pinning"><a class="header" href="#pinning">Pinning</a></h2>
<p>The current finalized block reported in the <code>initialized</code> event, and each subsequent block reported with a <code>newBlock</code> event, is automatically considered by the JSON-RPC server as <em>pinned</em>. A block is guaranteed to not leave the node's memory for as long as it is pinned, making it possible to call functions such as <code>chainHead_unstable_header</code> on it. Blocks must be unpinned by the JSON-RPC client by calling <code>chainHead_unstable_unpin</code>.</p>
<p>A block is pinned only in the context of a specific subscription. If multiple <code>chainHead_unstable_follow</code> subscriptions exist, then each <code>(subscription, block)</code> tuple must be unpinned individually. Blocks stay pinned even if they have been pruned from the blockchain, and must always be unpinned by the JSON-RPC client.</p>
<p>The JSON-RPC server is strongly encouraged to enforce a limit to the maximum number of pinned blocks. If this limit is reached, it should then stop the subscription by emitting a <code>stop</code> event. This specification does not mention any specific limit, but it should be large enough for clients to be able to pin all existing non-finalized blocks and a few finalized blocks.</p>
<p><strong>Note</strong>: A JSON-RPC client should call <code>chainHead_unstable_unpin</code> only after it is sure to no longer be interested in a certain block. This typically happens after the block has been finalized or pruned. There is no requirement to call <code>chainHead_unstable_unpin</code> as quickly as possible.</p>
<h2 id="multiple-subscriptions"><a class="header" href="#multiple-subscriptions">Multiple subscriptions</a></h2>
<p>If a JSON-RPC client maintains mutiple <code>chainHead_unstable_follow</code> subscriptions at the same time, it has no guarantee that the blocks reported by the various subscriptions are the same. While the finalized blocks reported should eventually be the same, it is possible that in the short term some subscriptions lag behind others.</p>
<p><strong>Note</strong>: For example, imagine there exists two active <code>chainHead_unstable_follow</code> subscriptions named A and B. Block N is announced on the peer-to-peer network and is announced to A. But then a sibling of block N gets finalized, leading to block N being pruned. Block N might never be announced to B.</p>
<h2 id="about-the-runtime"><a class="header" href="#about-the-runtime">About the runtime</a></h2>
<p>The format of the <code>finalizedBlockRuntime</code> and <code>newRuntime</code> fields can be one of:</p>
<h4 id="valid"><a class="header" href="#valid">valid</a></h4>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;valid&quot;,
    &quot;spec&quot;: {
        &quot;specName&quot;: ...,
        &quot;implName&quot;: ...,
        &quot;authoringVersion&quot;: ...,
        &quot;specVersion&quot;: ...,
        &quot;implVersion&quot;: ...,
        &quot;transactionVersion&quot;: ...,
        &quot;apis&quot;: [...],
    }
}
</code></pre>
<p>In normal situations, the <code>type</code> is <code>valid</code>.</p>
<p>The fields of <code>spec</code> are:</p>
<ul>
<li>
<p><code>specName</code>: Opaque string indicating the name of the chain.</p>
</li>
<li>
<p><code>implName</code>: Opaque string indicating the name of the implementation of the chain.</p>
</li>
<li>
<p><code>authoringVersion</code>: Opaque integer. Used by the internals of validator nodes that use a native executor in order to be sure that their native executor matches the WebAssembly code.</p>
</li>
<li>
<p><code>specVersion</code>: Opaque integer. The JSON-RPC client can assume that the call to <code>Metadata_metadata</code> will always produce the same output as long as the <code>specVersion</code> is the same.</p>
</li>
<li>
<p><code>implVersion</code>: Opaque integer. Whenever the runtime code changes in a backwards-compatible way, the <code>implVersion</code> is modified while the <code>specVersion</code> is left untouched.</p>
</li>
<li>
<p><code>transactionVersion</code>: Opaque integer. Necessary when building the bytes of an extrinsic. Extrinsics that have been generated with a different <code>transactionVersion</code> are incompatible.</p>
</li>
<li>
<p><code>apis</code>: Object containing a list of &quot;entry point APIs&quot; supported by the runtime. Each key is a string containing the hex-encoded 8-bytes blake2 hash of the name of the API, and each value is an integer version number. Before making a runtime call (using <code>chainHead_unstable_call</code>), you should make sure that this list contains the entry point API corresponding to the call and with a known version number.</p>
</li>
</ul>
<p><strong>Note</strong>: The format of <code>apis</code> is not the same as in the legacy JSON-RPC API.</p>
<h4 id="example-value"><a class="header" href="#example-value">Example value</a></h4>
<pre><code class="language-json">{
    &quot;specName&quot;: &quot;westend&quot;,
    &quot;implName&quot;: &quot;parity-westend&quot;,
    &quot;authoringVersion&quot;: 2,
    &quot;specVersion&quot;: 9122,
    &quot;implVersion&quot;: 0,
    &quot;transactionVersion&quot;: 7,
    &quot;apis&quot;: {
        &quot;0xdf6acb689907609b&quot;: 3
        &quot;0x37e397fc7c91f5e4&quot;: 1,
        &quot;0x40fe3ad401f8959a&quot;: 5,
        &quot;0xd2bc9897eed08f15&quot;: 3,
        &quot;0xf78b278be53f454c&quot;: 2,
        &quot;0xaf2c0297a23e6d3d&quot;: 1,
        &quot;0x49eaaf1b548a0cb0&quot;: 1,
        &quot;0x91d5df18b0d2cf58&quot;: 1,
        &quot;0xed99c5acb25eedf5&quot;: 3,
        &quot;0xcbca25e39f142387&quot;: 2,
        &quot;0x687ad44ad37f03c2&quot;: 1,
        &quot;0xab3c0572291feb8b&quot;: 1,
        &quot;0xbc9d89904f5b923f&quot;: 1,
        &quot;0x37c8bb1350a9a2a8&quot;: 1
    }
}
</code></pre>
<h3 id="invalid"><a class="header" href="#invalid">invalid</a></h3>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;invalid&quot;,
    &quot;error&quot;: &quot;...&quot;
}
</code></pre>
<p>The runtime is of type <code>invalid</code> if the JSON-RPC server considers the runtime as invalid, for example because the WebAssembly runtime code doesn't match its expectations.</p>
<p><code>error</code> is a human-readable string indicating why the node considers it as invalid. This string isn't meant to be shown to end users, but is for developers to understand the problem.</p>
<p><strong>Note</strong>: The typical situation where a node could consider the runtime as invalid is a light client after a warp syncing. The light client knows that it's its fault for considering the runtime as invalid, but it has no better way to handle this situation than to return an error through the JSON-RPC interface for the error to get shown to the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_genesishash"><a class="header" href="#chainhead_unstable_genesishash">chainHead_unstable_genesisHash</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: String containing the hexadecimal-encoded hash of the genesis block of the chain.</p>
<p>This function is a simple getter. The JSON-RPC server is expected to keep in its memory the hash of the genesis block.</p>
<p>The value returned by this function must never change for the lifetime of the connection between the JSON-RPC client and server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_header"><a class="header" href="#chainhead_unstable_header">chainHead_unstable_header</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
<li><code>hash</code>: String containing the hexadecimal-encoded hash of the header to retrieve.</li>
</ul>
<p><strong>Return value</strong>:</p>
<ul>
<li>If the <code>followSubscriptionId</code> is still alive (the vast majority of the time), the hexadecimal-encoded SCALE-encoded header of the block.</li>
<li>If the <code>followSubscriptionId</code> is dead, <em>null</em>.</li>
</ul>
<p>Retrieves the header of a pinned block.</p>
<p>This function should be seen as a complement to <code>chainHead_unstable_follow</code>, allowing the JSON-RPC client to retrieve more information about a block that has been reported. Use <code>archive_header_v1</code> if instead you want to retrieve the header of an arbitrary block.</p>
<p><strong>Note</strong>: As explained in the documentation of <code>chainHead_unstable_follow</code>, the JSON-RPC server reserves the right to kill an existing subscription and unpin all its blocks at any moment in case it is overloaded or incapable of following the chain. If that happens, <code>chainHead_unstable_header</code> will return <code>null</code>.</p>
<h2 id="possible-errors-6"><a class="header" href="#possible-errors-6">Possible errors</a></h2>
<ul>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is invalid.</li>
<li>A JSON-RPC error is generated if the block hash passed as parameter doesn't correspond to any block that has been reported by <code>chainHead_unstable_follow</code>.</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is valid but the block hash passed as parameter has already been unpinned.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_stopbody"><a class="header" href="#chainhead_unstable_stopbody">chainHead_unstable_stopBody</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_body</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a body fetch started with <code>chainHead_unstable_body</code>. If the body fetch was still in progress, this interrupts it. If the body fetch was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this body fetch, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-7"><a class="header" href="#possible-errors-7">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_stopcall"><a class="header" href="#chainhead_unstable_stopcall">chainHead_unstable_stopCall</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_call</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a call started with <code>chainHead_unstable_call</code>. If the call was still in progress, this interrupts it. If the call was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this call, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-8"><a class="header" href="#possible-errors-8">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_stopstorage"><a class="header" href="#chainhead_unstable_stopstorage">chainHead_unstable_stopStorage</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_storage</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a storage fetch started with <code>chainHead_unstable_storage</code>. If the storage fetch was still in progress, this interrupts it. If the storage fetch was already finished, this call has no effect.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive a notification about this storage fetch, for example because this notification was already in the process of being sent back by the JSON-RPC server.</p>
<h2 id="possible-errors-9"><a class="header" href="#possible-errors-9">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_storage"><a class="header" href="#chainhead_unstable_storage">chainHead_unstable_storage</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
<li><code>hash</code>: String containing an hexadecimal-encoded hash of the header of the block whose storage to fetch.</li>
<li><code>key</code>: String containing the hexadecimal-encoded key to fetch in the storage.</li>
<li><code>childKey</code>: <code>null</code> for main storage look-ups, or a string containing the hexadecimal-encoded key of the trie key of the trie that <code>key</code> refers to. <strong>TODO</strong>: I don't know enough about child tries to design this properly</li>
<li><code>type</code>: String that must be equal to one of: <code>value</code>, <code>hash</code>, or <code>size</code>.</li>
<li><code>networkConfig</code> (optional): Object containing the configuration of the networking part of the function. See <a href="api/./introduction.html">here</a> for details. Ignored if the JSON-RPC server doesn't need to perform a network request. Sensible defaults are used if not provided.</li>
</ul>
<p><strong>Return value</strong>: An opaque string that identifies the storage fetch in progress.</p>
<p>The JSON-RPC server must start obtaining the value of the entry with the given <code>key</code> (and possibly <code>childKey</code>) from the storage.</p>
<p>For optimization purposes, the JSON-RPC server is allowed to wait a little bit (e.g. up to 100ms) before starting to try fulfill the storage request, in order to batch multiple storage requests together.</p>
<h2 id="notifications-format-1"><a class="header" href="#notifications-format-1">Notifications format</a></h2>
<p>This function will later generate notifications in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;chainHead_unstable_storageEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>subscriptionId</code> is equal to the value returned by this function, and <code>result</code> can be one of:</p>
<p>### done</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;done&quot;,
    &quot;value&quot;: &quot;0x0000000...&quot;
}
</code></pre>
<p>The <code>done</code> event indicates that everything went well. The <code>value</code> field contains the requested value.</p>
<p>Where <code>value</code> is:</p>
<ul>
<li>If <code>type</code> was <code>value</code>, either <code>null</code> if the storage doesn't contain a value at the given key, or a string containing the hexadecimal-encoded value of the storage entry.</li>
<li>If <code>type</code> was <code>hash</code>, either <code>null</code> if the storage doesn't contain a value at the given key, or a string containing the hexadecimal-encoded hash of the value of the storage item. The hashing algorithm is the same as the one used by the trie of the chain.</li>
<li>If <code>type</code> was <code>size</code>, either <code>null</code> if the storage doesn't contain a value at the given key, or a string containing the number of bytes of the storage entry. Note that a string is used rather than a number in order to prevent JavaScript clients from accidentally rounding the value.</li>
</ul>
<h3 id="failed"><a class="header" href="#failed">failed</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;failed&quot;
}
</code></pre>
<p>The <code>failed</code> event indicates that the storage value has failed to be retrieved from the network.</p>
<h3 id="disjoint"><a class="header" href="#disjoint">disjoint</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;disjoint&quot;
}
</code></pre>
<p>The <code>disjoint</code> event indicates that the provided <code>followSubscriptionId</code> is dead.</p>
<p><strong>Note</strong>: Other events might be added in the future, such as reports on the progress of the fetch.</p>
<h2 id="possible-errors-10"><a class="header" href="#possible-errors-10">Possible errors</a></h2>
<ul>
<li>A JSON-RPC error is generated if <code>type</code> isn't one of the allowed values (similarly to a missing parameter or an invalid parameter type).</li>
<li>If the networking part of the behaviour fails, then a <code>{&quot;event&quot;: &quot;failed&quot;}</code> notification is generated (as explained above).</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is invalid.</li>
<li>If the <code>followSubscriptionId</code> is dead, then a <code>{&quot;event&quot;: &quot;disjoint&quot;}</code> notification is generated (as explained above).</li>
<li>A JSON-RPC error is generated if the block hash passed as parameter doesn't correspond to any block that has been reported by <code>chainHead_unstable_follow</code>.</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is valid but the block hash passed as parameter has already been unpinned.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_unfollow"><a class="header" href="#chainhead_unstable_unfollow">chainHead_unstable_unfollow</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>Stops a subscription started with <code>chainHead_unstable_follow</code>.</p>
<p>JSON-RPC client implementations must be aware that, due to the asynchronous nature of JSON-RPC client &lt;-&gt; server communication, they might still receive chain updates notifications, for example because these notifications were already in the process of being sent back by the JSON-RPC server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_unpin"><a class="header" href="#chainhead_unstable_unpin">chainHead_unstable_unpin</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>followSubscriptionId</code>: An opaque string that was returned by <code>chainHead_unstable_follow</code>.</li>
<li><code>hash</code>: String containing the hexadecimal-encoded hash of the header of the block to unpin.</li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p>See explanations in the documentation of <code>chainHead_unstable_follow</code>.</p>
<h2 id="possible-errors-11"><a class="header" href="#possible-errors-11">Possible errors</a></h2>
<ul>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> doesn't correspond to any active subscription.</li>
<li>A JSON-RPC error is generated if the block hash passed as parameter doesn't correspond to any block that has been reported by <code>chainHead_unstable_follow</code>.</li>
<li>A JSON-RPC error is generated if the <code>followSubscriptionId</code> is valid but the block hash passed as parameter has already been unpinned.</li>
<li>No error is generated if the <code>followSubscriptionId</code> is dead. The call is simply ignored.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainhead_unstable_wasmquery"><a class="header" href="#chainhead_unstable_wasmquery">chainHead_unstable_wasmQuery</a></h1>
<p><strong>TODO</strong>: allow passing a Wasm blob that is executed by a remote</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h1>
<p>The functions with the <code>chainSpec</code> prefix allow inspecting the content of the specification of the chain a JSON-RPC server is targeting.</p>
<p>Because the chain specification never changes while a JSON-RPC server is running, the return value of all these functions must never change and can be cached by the JSON-RPC client.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainspec_unstable_chainname"><a class="header" href="#chainspec_unstable_chainname">chainSpec_unstable_chainName</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: String containing the human-readable name of the chain.</p>
<p>The value returned by this function must never change for the lifetime of the connection between the JSON-RPC client and server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainspec_unstable_genesishash"><a class="header" href="#chainspec_unstable_genesishash">chainSpec_unstable_genesisHash</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: String containing the hexadecimal-encoded hash of the genesis block of the chain.</p>
<p>This function is a simple getter. The JSON-RPC server is expected to keep in its memory the hash of the genesis block.</p>
<p>The value returned by this function must never change for the lifetime of the connection between the JSON-RPC client and server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainspec_unstable_properties"><a class="header" href="#chainspec_unstable_properties">chainSpec_unstable_properties</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: <em>any</em></p>
<p>Returns the JSON payload found in the chain specification under the key <code>properties</code>. No guarantee is offered about the content of this object.</p>
<p>The value returned by this function must never change for the lifetime of the connection between the JSON-RPC client and server.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Because no guarantee is offered about the nature of the returned value, this JSON-RPC function should preferably be used in a context where the JSON-RPC client knows what the <code>properties</code> field contains.</p>
<p>The <code>properties</code> field is a useful way for a chain developer to store important information about their chain, such as the name of the token or the number of decimals. Without this field, important constants would need to be copy-pasted across all UIs that connect to said chain, potentially leading to mistakes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h1>
<p>The <code>extrinsic</code> functions allow submitting an extrinsic for inclusion in the chain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extrinsic_unstable_submitandwatch"><a class="header" href="#extrinsic_unstable_submitandwatch">extrinsic_unstable_submitAndWatch</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>extrinsic</code>: String containing the hexadecimal-encoded SCALE-encoded extrinsic to try to include in a block.</li>
</ul>
<p><strong>Return value</strong>: String representing the subscription.</p>
<p>The string returned by this function is opaque and its meaning can't be interpreted by the JSON-RPC client. It is only meant to be matched with the <code>subscriptionId</code> field of events and potentially passed to <code>extrinsic_unstable_unwatch</code>.</p>
<h2 id="notifications-format-2"><a class="header" href="#notifications-format-2">Notifications format</a></h2>
<p>This function will later generate one or more notifications in the following format:</p>
<pre><code class="language-json">{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;extrinsic_unstable_watchEvent&quot;,
    &quot;params&quot;: {
        &quot;subscriptionId&quot;: &quot;...&quot;,
        &quot;result&quot;: ...
    }
}
</code></pre>
<p>Where <code>subscriptionId</code> is the value returned by this function, and <code>result</code> can be one of:</p>
<h3 id="validated"><a class="header" href="#validated">validated</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;validated&quot;
}
</code></pre>
<p>The <code>validated</code> event indicates that this extrinsic has been checked and is considered as valid by the runtime.</p>
<p>This extrinsic might still become invalid in the future, for example because a conflicting extrinsic is included in the chain in-between.</p>
<p>Multiple <code>validated</code> events can be generated during the lifetime of an extrinsic. If multiple <code>validated</code> events happen in a row, the JSON-RPC server is allowed to skip all but the last one.</p>
<p><strong>Note</strong>: In theory, this event could include a field indicating the block against which this extrinsic was validated. It has been decided to not include this field for pragmatic reasons: implementing it might be complicated, and it is not very useful for a JSON-RPC client to know this information.</p>
<h3 id="broadcasted"><a class="header" href="#broadcasted">broadcasted</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;broadcasted&quot;,
    &quot;numPeers&quot;: ...
}
</code></pre>
<p>The <code>broadcasted</code> event indicates the number of other peers this extrinsic has been broadcasted to.</p>
<p><code>numPeers</code> is the total number of individual peers this extrinsic has been broadcasted to.</p>
<p>The JSON-RPC server doesn't (and can't) offer any guarantee that these peers have received the extrinsic or have saved it in their own transactions pool. In other words, no matter how large the value in <code>numPeers</code> is, no guarantee is offered that shutting down the local node will lead to the extrinsic being included.</p>
<p><strong>Note</strong>: In principle, a value of <code>numPeers</code> equal to 0 guarantees that shutting down the local node will lead to the extrinsic <em>not</em> being included, assuming that no other node has submitted the same extrinsic. However, because JSON-RPC servers are allowed to delay or skip events, the JSON-RPC client can never be sure that <code>numPeers</code> was still equal to 0 when shutting down the node.</p>
<p>If multiple <code>broadcasted</code> events happen in a row, the JSON-RPC server is allowed to skip all but the last.</p>
<h3 id="bestchainblockincluded"><a class="header" href="#bestchainblockincluded">bestChainBlockIncluded</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;bestChainBlockIncluded&quot;,
    &quot;block&quot;: {
        &quot;hash&quot;: &quot;...&quot;,
        &quot;index&quot;: &quot;...&quot;
    }
}
</code></pre>
<p>Or</p>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;bestChainBlockIncluded&quot;,
    &quot;block&quot;: null
}
</code></pre>
<p>The <code>bestChainBlockIncluded</code> event indicates which block of the best chain the extrinsic is included in.</p>
<p><code>null</code> can be sent back in case the block is no longer in any block of the best chain. This is the state an extrinsic starts in.</p>
<p><code>hash</code> is a string containing the hex-encoded hash of the header of the block. <code>index</code> is a string containing an integer indicating the 0-based index of this extrinsic within the body of this block.</p>
<p>If multiple <code>bestChainBlockIncluded</code> events happen in a row, the JSON-RPC server is allowed to skip all but the last.</p>
<p><strong>Note</strong>: Please note that these is no guarantee that the mentioned block matches any of the blocks returned by <code>chainHead_unstable_follow</code>.</p>
<h3 id="finalized-1"><a class="header" href="#finalized-1">finalized</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;finalized&quot;,
    &quot;block&quot;: {
        &quot;hash&quot;: &quot;...&quot;,
        &quot;index&quot;: &quot;...&quot;
    }
}
</code></pre>
<p>The <code>finalized</code> event indicates that this extrinsic is present in a block of the chain that is finalized.</p>
<p><code>hash</code> is a string containing the hex-encoded hash of the header of the block. <code>index</code> is a string containing an integer indicating the 0-based index of this extrinsic within the body of this block.</p>
<p>No more event will be generated about this extrinsic.</p>
<h3 id="error"><a class="header" href="#error">error</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;error&quot;,
    &quot;error&quot;: &quot;...&quot;
}
</code></pre>
<p>The <code>error</code> event indicates that an internal error within the client has happened.</p>
<p>Examples include: the runtime crashes, the runtime is missing the function to validate an extrinsic, the format of the value returned by the runtime is invalid, etc.</p>
<p>This typically indicates a bug in the runtime of the chain or an incompatibility between the client and the runtime of the chain, and there is nothing the end user can do to fix the problem.</p>
<p>The extrinsic that has been submitted will not be included in the chain by the local node, but it could be included by sending it via a different client implementation.</p>
<p><code>error</code> is a human-readable error message indicating what happened. This string isn't meant to be shown to end users, but is for developers to understand the problem.</p>
<p>No more event will be generated about this extrinsic.</p>
<h3 id="invalid-1"><a class="header" href="#invalid-1">invalid</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;invalid&quot;,
    &quot;error&quot;: &quot;...&quot;
}
</code></pre>
<p>The <code>invalid</code> event indicates that the runtime has marked the extrinsic as invalid.</p>
<p>This can happen for a variety of reasons specific to the chain, such as a bad signature, bad nonce, not enough balance for fees, etc.</p>
<p><code>error</code> is a human-readable error message indicating why the extrinsic is invalid. This string isn't meant to be shown to end users, but is for developers to understand the problem.</p>
<p>No more event will be generated about this extrinsic.</p>
<h3 id="dropped"><a class="header" href="#dropped">dropped</a></h3>
<pre><code class="language-json">{
    &quot;event&quot;: &quot;dropped&quot;,
    &quot;broadcasted&quot;: true,
    &quot;error&quot;: &quot;...&quot;
}
</code></pre>
<p>The <code>dropped</code> event indicates that the client wasn't capable of keeping track of this extrinsic.</p>
<p>If the <code>broadcasted</code> field is <code>true</code>, then this extrinsic has been sent to other peers and might still be included in the chain in the future. No guarantee is offered that the extrinsic will be included in the chain even if <code>broadcasted</code> is <code>true</code>. However, if <code>broadcasted</code> is <code>false</code>, then it is guaranteed that this extrinsic will not be included, unless it has been submitted in parallel on a different node.</p>
<p>This can happen for example if the JSON-RPC server's extrinsics pool is full, if the JSON-RPC server's resources have reached their limit, if the block the extrinsic is included in takes too long to be finalized, or the syncing requires a gap in the chain that prevents the JSON-RPC server from knowing whether the extrinsic has been included and/or finalized.</p>
<p><code>error</code> is a human-readable error message indicating why the extrinsic has been dropped. This string isn't meant to be shown to end users, but is for developers to understand the problem.</p>
<p>No more event will be generated about this extrinsic.</p>
<h2 id="extrinsic-state"><a class="header" href="#extrinsic-state">Extrinsic state</a></h2>
<p>One can build a mental model in order to understand which events can be generated. While an extrinsic is being watched, it has the following properties:</p>
<ul>
<li>
<p><code>isValidated</code>: <code>yes</code> or <code>not-yet</code>. An extrinsic is initially <code>not-yet</code> validated. A <code>validated</code> event indicates that the extrinsic has now been validated. After a certain number of blocks or in case of retractation, an extrinsic automatically becomes <code>not-yet</code> validated and needs to be validated again. No event is generated to indicate that an extrinsic is no longer validated, however a <code>validated</code> event will be generated again when an extrinsic is validated again.</p>
</li>
<li>
<p><code>bestChainBlockIncluded</code>: an optional block hash and index. An extrinsic is initially included in no block. It can automatically become included in a block of the best chain. A <code>bestChainBlockIncluded</code> event reports updates to this property.</p>
</li>
<li>
<p><code>numBroadcastedPeers</code>: <em>integer</em>. An extrinsic is initially broadcasted to 0 other peers. After an extrinsic is in the <code>isValidated: yes</code> and <code>bestChainBlockIncluded: none</code> states, the number of broadcaster peers can increase. This number never decreases and is never reset to 0, even if an extrinsic becomes <code>isValidated: not-yet</code>. The <code>broadcasted</code> event is used to report about updates to this value.</p>
</li>
</ul>
<p>Note that these three properties are orthogonal to each other, except for the fact that <code>numBroadcastedPeers</code> can only increase when <code>isValidated: yes</code> and <code>bestChainBlockIncluded: none</code>. In particular, an extrinsic can be included in a block before being validated or broadcasted.</p>
<p>The <code>finalized</code>, <code>error</code>, <code>invalid</code>, and <code>dropped</code> event indicate that the extrinsic is no longer being watched. The state of the extrinsic is entirely discarded.</p>
<p>JSON-RPC servers are allowed to skip sending events as long as it properly keeps the JSON-RPC client up to date with the state of the extrinsic. In other words, multiple <code>validated</code>, <code>broadcasted</code>, or <code>bestChainBlockIncluded</code> events in a row might be merged into one.</p>
<p><strong>Note</strong>: In order to implement this properly, JSON-RPC servers should maintain a buffer of three notifications (one for each property), and overwrite any unsent notification with a more recent status update.</p>
<h2 id="possible-errors-12"><a class="header" href="#possible-errors-12">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>extrinsic</code> parameter has an invalid format, but no error is produced if the bytes of the <code>extrinsic</code>, once decoded, are invalid. Instead, an <code>invalid</code> notification will be generated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extrinsic_unstable_unwatch"><a class="header" href="#extrinsic_unstable_unwatch">extrinsic_unstable_unwatch</a></h1>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>subscription</code>: Opaque string equal to the value returned by <code>extrinsic_unstable_submitAndWatch</code></li>
</ul>
<p><strong>Return value</strong>: <em>null</em></p>
<p><strong>Note</strong>: This function does not remove the extrinsic from the pool. In other words, the node will still try to include the extrinsic in the chain. Having a function that removes the extrinsic from the pool would be almost useless, as the node might have already gossiped it to the rest of the network.</p>
<h2 id="possible-errors-13"><a class="header" href="#possible-errors-13">Possible errors</a></h2>
<p>A JSON-RPC error is generated if the <code>subscriptionId</code> doesn't correspond to any active subscription.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h1>
<p>The <code>rpc_methods</code> function is the only one without a version number. It can be used by JSON-RPC clients in order to determine which functions the JSON-RPC server supports.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc_methods"><a class="header" href="#rpc_methods">rpc_methods</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: Array of strings indicating the names of all the JSON-RPC functions supported by the JSON-RPC server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h1>
<p>The functions with the <code>sudo</code> prefix are targeted at blockchain node operators who want to inspect the state of their blockchain node.</p>
<p>Contrary to functions with other prefixes, functions with the <code>sudo</code> prefix are meant to be called on a specific JSON-RPC server, and not for example on a load balancer. When implementing a load balancer in front of multiple JSON-RPC servers, functions with the <code>sudo</code> prefix should be forbidden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sudo_unstable_addreservedpeer"><a class="header" href="#sudo_unstable_addreservedpeer">sudo_unstable_addReservedPeer</a></h1>
<p><strong>TODO</strong>: same as <code>system_addReservedPeer</code> but properly defined</p>
<p><strong>TODO</strong>: is this function actually necessary?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sudo_unstable_pendingextrinsics"><a class="header" href="#sudo_unstable_pendingextrinsics">sudo_unstable_pendingExtrinsics</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: Array of string containing hexadecimal-encoded SCALE-encoded extrinsics that are in the transactions pool of the node.</p>
<p><strong>TODO</strong>: is this function actually necessary?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sudo_unstable_removereservedpeer"><a class="header" href="#sudo_unstable_removereservedpeer">sudo_unstable_removeReservedPeer</a></h1>
<p><strong>TODO</strong>: same as <code>system_removeReservedPeer</code> but properly defined</p>
<p><strong>TODO</strong>: is this function actually necessary?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sudo_unstable_rotatekeys"><a class="header" href="#sudo_unstable_rotatekeys">sudo_unstable_rotateKeys</a></h1>
<p><strong>TODO</strong>: same as <code>author_rotateKeys</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sudo_unstable_version"><a class="header" href="#sudo_unstable_version">sudo_unstable_version</a></h1>
<p><strong>Parameters</strong>: <em>none</em></p>
<p><strong>Return value</strong>: String containing a human-readable name and version of the implementation of the JSON-RPC server.</p>
<p>The return value shouldn't be parsed by a program. It is purely meant to be shown to a human.</p>
<p><strong>Note</strong>: Example return values: &quot;polkadot 0.9.12-ec34cf7e0-x86_64-linux-gnu&quot;, &quot;smoldot-light 0.5.4&quot;</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
